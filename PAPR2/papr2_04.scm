; oboustrany seznam
(define make-dlist
  (lambda ()
    (let ((dlist '()))
      
      (define dlist-cons (lambda (elem)
                           (let ((new-cell (cons elem (cons '() dlist))))
                             (if (not (null? dlist))
                                 (set-car! (cdr dlist) new-cell))
                             (set! dlist new-cell))))
      
      (define dlist-car (lambda (dlist) (car dlist))) 
      (define dlist-cdr (lambda (dlist) (cddr dlist))) 
      (define dlist-cir (lambda (dlist)  (cadr dlist)))
      
      (define dlist-print (lambda ()
                            (display "<")
                            (let iter ((l dlist))
                              (if (null? l) '()
                                  (begin
                                    (display (dlist-car l))
                                    (if (not (null? (dlist-cdr l))) (display ", "))
                                    (iter (dlist-cdr l)))))
                            (display ">\n")))
      
      (define insert (lambda (elem index)
                       (if (= index 0)
                           (dlist-cons elem)
                           (let iter ((l dlist) (i (- index 1)))
                             (cond ((= i 0) (if (null? (dlist-cdr l)) #f
                                                (let ((new-cell (cons elem (cons '() '()))))
                                                  (set-car! (cdr (dlist-cdr l)) new-cell)
                                                  (set-car! (cdr new-cell) l)
                                                  (set-cdr! (cdr new-cell) (dlist-cdr l))
                                                  (set-cdr! (cdr l) new-cell))))
                                   ((null? (dlist-cdr l)) #f)
                                   (else (iter (dlist-cdr l) (- i 1))))))))
      
      (define delete (lambda (index)
                       (if (= index 0)
                           (begin
                             (set! dlist (dlist-cdr dlist))
                             (set-cdr! (cdr (dlist-cir dlist)) '())
                             (set-car! (cdr dlist) '()))
                           (let iter ((l dlist) (i index ))
                             (cond ((and (> i 0) (null? (dlist-cdr l))) #f)
                                   ((= i 0) (if (null? (dlist-cdr l))
                                                (begin
                                                  (set-cdr! (cdr (dlist-cir l)) '())
                                                  (set-car! (cdr l) '()))
                                                (begin
                                                  (set-car! (cdr (dlist-cdr l)) (dlist-cir l))
                                                  (set-cdr! (cdr (dlist-cir l)) (dlist-cdr l))
                                                  (set-cdr! l '()))))
                                   (else (iter (dlist-cdr l) (- i 1))))))))
      
      (lambda (signal . args)
        (cond ((equal? signal 'dcar) (dlist-car dlist))
              ((equal? signal 'dcdr) (dlist-cdr dlist))
              ((equal? signal 'dcir) (dlist-cir dlist))
              ((equal? signal 'dcons) (dlist-cons (car args)))
              ((equal? signal 'print) (dlist-print))
              ((equal? signal 'get) dlist)
              ((equal? signal 'insert) (insert (car args) (cadr args)))
              ((equal? signal 'delete) (delete (car args)))
              (else (display "error\n"))
              ))
      )))

(define s (make-dlist))
(s 'print)
(s 'dcons 'a)
(s 'print)
(s 'dcons 'b)
(s 'print)
(s 'insert 'x 0)
(s 'print)
(s 'insert 'y 1)
(s 'print)
(s 'insert 'z 50)
(s 'delete 2)
(s 'print)
(s 'delete 2)
(s 'print)
(s 'delete 100)
(s 'get)